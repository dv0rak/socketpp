\hypertarget{classsocketpp_1_1AddrHandler}{
\section{socketpp::AddrHandler Class Reference}
\label{classsocketpp_1_1AddrHandler}\index{socketpp::AddrHandler@{socketpp::AddrHandler}}
}
Class which deals with several things, like dns resolving or address format conversion.  


{\tt \#include $<$AddrHandler.h$>$}

\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
in\_\-addr\_\-t \hyperlink{classsocketpp_1_1AddrHandler_79db1454cc9c12bbd44b526f61ff84fb}{getAddrByRoute} (in\_\-addr\_\-t to)
\begin{CompactList}\small\item\em gets IP source address to reach given destination address, watching kernel routing table \item\end{CompactList}\item 
std::vector$<$ std::string $>$ \hyperlink{classsocketpp_1_1AddrHandler_d840f7fee97d701511f09459bef35748}{gethostbyname} (const std::string \&name)
\begin{CompactList}\small\item\em resolves given name through a DNS lookup \item\end{CompactList}\item 
std::string \hyperlink{classsocketpp_1_1AddrHandler_2e9b9e6dc7ea4fc4a3500665b3f4062d}{gethostbyaddr} (const std::string \&addr)
\begin{CompactList}\small\item\em tries to obtain an hostname from a IP address, through a reverse DNS lookup \item\end{CompactList}\item 
\hypertarget{classsocketpp_1_1AddrHandler_89a2929af6c042fd7e16661303dfabcb}{
void \hyperlink{classsocketpp_1_1AddrHandler_89a2929af6c042fd7e16661303dfabcb}{cleanDnsCache} ()}
\label{classsocketpp_1_1AddrHandler_89a2929af6c042fd7e16661303dfabcb}

\begin{CompactList}\small\item\em cleans internal DNS cache \item\end{CompactList}\item 
\hypertarget{classsocketpp_1_1AddrHandler_b0830c79eecab9f9d5ac47c3d44cb1c9}{
void \hyperlink{classsocketpp_1_1AddrHandler_b0830c79eecab9f9d5ac47c3d44cb1c9}{cleanRouteCache} ()}
\label{classsocketpp_1_1AddrHandler_b0830c79eecab9f9d5ac47c3d44cb1c9}

\begin{CompactList}\small\item\em clean internal route table cache \item\end{CompactList}\end{CompactItemize}
\subsection*{Static Public Member Functions}
\begin{CompactItemize}
\item 
static port\_\-t \hyperlink{classsocketpp_1_1AddrHandler_aa24239225e2a35cce9322dfa68bf438}{getservbyname} (const std::string \&name)
\begin{CompactList}\small\item\em obtains port conventionally bound to given service name \item\end{CompactList}\item 
static std::string \hyperlink{classsocketpp_1_1AddrHandler_c099c4bdf0b45e5d4a1e5806d896768e}{getservbyport} (port\_\-t port, gai\_\-proto prot=tcp)
\begin{CompactList}\small\item\em obtains service name conventionally bound to given port \item\end{CompactList}\item 
static bool \hyperlink{classsocketpp_1_1AddrHandler_652e24c273f7905cebf8d04b3cfef74d}{isIPv4} (const std::string \&str)  throw ()
\begin{CompactList}\small\item\em checks whether given string is in IPv4 format \item\end{CompactList}\item 
static in\_\-addr\_\-t \hyperlink{classsocketpp_1_1AddrHandler_e2eda37cd4c20059c557e4e65c829cf8}{inet\_\-aton} (const std::string \&str)
\begin{CompactList}\small\item\em conversion from IPv4 string format to numerical one \item\end{CompactList}\item 
static std::string \hyperlink{classsocketpp_1_1AddrHandler_a4377d84c8ea976aeada2b2eb0ac248d}{inet\_\-ntoa} (in\_\-addr\_\-t addr)
\begin{CompactList}\small\item\em conversion from IPv4 numerical format to dotted decimal one \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
Class which deals with several things, like dns resolving or address format conversion. 

\subsection{Member Function Documentation}
\hypertarget{classsocketpp_1_1AddrHandler_79db1454cc9c12bbd44b526f61ff84fb}{
\index{socketpp::AddrHandler@{socketpp::AddrHandler}!getAddrByRoute@{getAddrByRoute}}
\index{getAddrByRoute@{getAddrByRoute}!socketpp::AddrHandler@{socketpp::AddrHandler}}
\subsubsection[{getAddrByRoute}]{\setlength{\rightskip}{0pt plus 5cm}in\_\-addr\_\-t socketpp::AddrHandler::getAddrByRoute (in\_\-addr\_\-t {\em to})}}
\label{classsocketpp_1_1AddrHandler_79db1454cc9c12bbd44b526f61ff84fb}


gets IP source address to reach given destination address, watching kernel routing table 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em to}]destination address \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]IP numerical address \end{Desc}
\hypertarget{classsocketpp_1_1AddrHandler_2e9b9e6dc7ea4fc4a3500665b3f4062d}{
\index{socketpp::AddrHandler@{socketpp::AddrHandler}!gethostbyaddr@{gethostbyaddr}}
\index{gethostbyaddr@{gethostbyaddr}!socketpp::AddrHandler@{socketpp::AddrHandler}}
\subsubsection[{gethostbyaddr}]{\setlength{\rightskip}{0pt plus 5cm}std::string socketpp::AddrHandler::gethostbyaddr (const std::string \& {\em addr})}}
\label{classsocketpp_1_1AddrHandler_2e9b9e6dc7ea4fc4a3500665b3f4062d}


tries to obtain an hostname from a IP address, through a reverse DNS lookup 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em addr}]IP address \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]hostname \end{Desc}
\hypertarget{classsocketpp_1_1AddrHandler_d840f7fee97d701511f09459bef35748}{
\index{socketpp::AddrHandler@{socketpp::AddrHandler}!gethostbyname@{gethostbyname}}
\index{gethostbyname@{gethostbyname}!socketpp::AddrHandler@{socketpp::AddrHandler}}
\subsubsection[{gethostbyname}]{\setlength{\rightskip}{0pt plus 5cm}std::vector$<$ std::string $>$ socketpp::AddrHandler::gethostbyname (const std::string \& {\em name})}}
\label{classsocketpp_1_1AddrHandler_d840f7fee97d701511f09459bef35748}


resolves given name through a DNS lookup 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em name}]hostname to resolve \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]vector of IP addresses \end{Desc}
\hypertarget{classsocketpp_1_1AddrHandler_aa24239225e2a35cce9322dfa68bf438}{
\index{socketpp::AddrHandler@{socketpp::AddrHandler}!getservbyname@{getservbyname}}
\index{getservbyname@{getservbyname}!socketpp::AddrHandler@{socketpp::AddrHandler}}
\subsubsection[{getservbyname}]{\setlength{\rightskip}{0pt plus 5cm}port\_\-t socketpp::AddrHandler::getservbyname (const std::string \& {\em name})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}}
\label{classsocketpp_1_1AddrHandler_aa24239225e2a35cce9322dfa68bf438}


obtains port conventionally bound to given service name 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em name}]service name \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]port number \end{Desc}
\hypertarget{classsocketpp_1_1AddrHandler_c099c4bdf0b45e5d4a1e5806d896768e}{
\index{socketpp::AddrHandler@{socketpp::AddrHandler}!getservbyport@{getservbyport}}
\index{getservbyport@{getservbyport}!socketpp::AddrHandler@{socketpp::AddrHandler}}
\subsubsection[{getservbyport}]{\setlength{\rightskip}{0pt plus 5cm}std::string socketpp::AddrHandler::getservbyport (port\_\-t {\em port}, \/  gai\_\-proto {\em prot} = {\tt tcp})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}}
\label{classsocketpp_1_1AddrHandler_c099c4bdf0b45e5d4a1e5806d896768e}


obtains service name conventionally bound to given port 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em port}]port number \item[{\em prot}]transport layer protocol \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]service name, empty string if failed \end{Desc}
\hypertarget{classsocketpp_1_1AddrHandler_e2eda37cd4c20059c557e4e65c829cf8}{
\index{socketpp::AddrHandler@{socketpp::AddrHandler}!inet\_\-aton@{inet\_\-aton}}
\index{inet\_\-aton@{inet\_\-aton}!socketpp::AddrHandler@{socketpp::AddrHandler}}
\subsubsection[{inet\_\-aton}]{\setlength{\rightskip}{0pt plus 5cm}in\_\-addr\_\-t socketpp::AddrHandler::inet\_\-aton (const std::string \& {\em str})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}}
\label{classsocketpp_1_1AddrHandler_e2eda37cd4c20059c557e4e65c829cf8}


conversion from IPv4 string format to numerical one 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em str}]IPv4 string \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]numerical address \end{Desc}
\hypertarget{classsocketpp_1_1AddrHandler_a4377d84c8ea976aeada2b2eb0ac248d}{
\index{socketpp::AddrHandler@{socketpp::AddrHandler}!inet\_\-ntoa@{inet\_\-ntoa}}
\index{inet\_\-ntoa@{inet\_\-ntoa}!socketpp::AddrHandler@{socketpp::AddrHandler}}
\subsubsection[{inet\_\-ntoa}]{\setlength{\rightskip}{0pt plus 5cm}std::string socketpp::AddrHandler::inet\_\-ntoa (in\_\-addr\_\-t {\em addr})\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}}
\label{classsocketpp_1_1AddrHandler_a4377d84c8ea976aeada2b2eb0ac248d}


conversion from IPv4 numerical format to dotted decimal one 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em addr}]numerical address \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]IPv4 dotted decimal string \end{Desc}
\hypertarget{classsocketpp_1_1AddrHandler_652e24c273f7905cebf8d04b3cfef74d}{
\index{socketpp::AddrHandler@{socketpp::AddrHandler}!isIPv4@{isIPv4}}
\index{isIPv4@{isIPv4}!socketpp::AddrHandler@{socketpp::AddrHandler}}
\subsubsection[{isIPv4}]{\setlength{\rightskip}{0pt plus 5cm}bool socketpp::AddrHandler::isIPv4 (const std::string \& {\em str})  throw ()\hspace{0.3cm}{\tt  \mbox{[}static\mbox{]}}}}
\label{classsocketpp_1_1AddrHandler_652e24c273f7905cebf8d04b3cfef74d}


checks whether given string is in IPv4 format 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em str}]string to check \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]true or false \end{Desc}


The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
AddrHandler.h\item 
AddrHandler.cpp\end{CompactItemize}
